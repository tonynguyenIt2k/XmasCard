<!DOCTYPE html>
<html lang="vi">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Merry Christmas (Sharp & Clean)</title>
    <style>
        body { margin: 0; overflow: hidden; background: #000; font-family: 'Times New Roman', serif; }
        #canvas-container { width: 100vw; height: 100vh; display: block; }

        /* UI Overlay */
        #title {
            position: absolute; top: 20px; width: 100%; text-align: center; color: #FFD700;
            font-size: 2.5rem; letter-spacing: 5px; text-shadow: 0 0 20px rgba(255, 215, 0, 0.8);
            pointer-events: none; z-index: 10; font-family: 'Cinzel', serif; font-weight: bold;
        }
        #instructions {
            position: absolute; bottom: 30px; width: 100%; text-align: center;
            color: rgba(255, 255, 255, 0.7); font-family: sans-serif; font-size: 1rem;
            pointer-events: none; z-index: 10;
        }
        #loading {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            color: #FFD700; background: rgba(0,0,0,0.8); padding: 15px 30px;
            border-radius: 8px; border: 1px solid #FFD700; z-index: 20;
        }
        .input_video {
            position: absolute; bottom: 10px; right: 10px; width: 160px; height: 120px;
            border-radius: 10px; border: 1px solid #444; transform: scaleX(-1);
            z-index: 15; opacity: 0.6;
        }
        /* Settings UI */
        #settings-btn {
            position: absolute; top: 20px; right: 20px; z-index: 100;
            background: rgba(0, 0, 0, 0.6); border: 1px solid #FFD700; color: #FFD700;
            font-size: 24px; width: 50px; height: 50px; border-radius: 50%;
            cursor: pointer; transition: 0.3s; display: flex; align-items: center; justify-content: center;
        }
        #settings-btn:hover { background: #FFD700; color: #000; }
        #create-new-link {
            position: absolute; top: 20px; right: 20px; z-index: 100;
            color: rgba(255,255,255,0.3); font-size: 12px; text-decoration: none;
            display: none; cursor: pointer; font-family: sans-serif;
        }
        #create-new-link:hover { color: #FFD700; text-decoration: underline; }
        #settings-modal {
            display: none; position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: rgba(0, 0, 0, 0.95); z-index: 200; align-items: center; justify-content: center;
        }
        .modal-content {
            background: #1a1a1a; padding: 25px; border-radius: 15px; border: 2px solid #FFD700;
            width: 90%; max-width: 550px; color: #fff; font-family: sans-serif;
            box-shadow: 0 0 50px rgba(255, 215, 0, 0.3);
            max-height: 95vh; overflow-y: auto;
        }
        .modal-content h2 { text-align: center; color: #FFD700; margin-top: 0; border-bottom: 1px solid #444; padding-bottom: 10px;}
        .form-group { margin-bottom: 12px; }
        .form-group label { display: block; margin-bottom: 5px; color: #aaa; font-size: 0.85rem;}
        .form-group input, .form-group textarea {
            width: 100%; padding: 8px; background: #333; border: 1px solid #555;
            color: #fff; border-radius: 5px; box-sizing: border-box; outline: none; font-size: 14px;
        }
        .file-upload-wrapper {
            border: 2px dashed #555; padding: 15px; text-align: center; border-radius: 5px; cursor: pointer; transition: 0.3s;
            background: #252525;
        }
        .file-upload-wrapper:hover { border-color: #FFD700; background: #333; }
        #file-count { color: #aaa; font-size: 0.8rem; margin-top:5px; }
        .btn-group { display: flex; gap: 10px; margin-top: 20px; }
        button.action-btn {
            flex: 1; padding: 12px; border: none; border-radius: 5px; cursor: pointer;
            font-weight: bold; font-size: 16px; transition: 0.2s;
        }
        .btn-save { background: #FFD700; color: #000; }
        .btn-save:hover { background: #ffea70; }
        .btn-save:disabled { background: #555; color: #888; cursor: not-allowed; }
        .btn-close { background: #444; color: #fff; }
        #share-link-container {
            margin-top: 20px; padding: 15px; background: #000; border: 1px dashed #444; border-radius: 5px; display: none;
        }
        #share-link {
            word-break: break-all; color: #4ade80; font-size: 12px; margin-bottom: 10px; font-family: monospace;
        }
        #youtube-player { position: absolute; width: 1px; height: 1px; opacity: 0; left: -9999px; }
    </style>
    <link href="https://fonts.googleapis.com/css2?family=Cinzel:wght@700&display=swap" rel="stylesheet">
</head>
<body>
    <div id="title">MERRY CHRISTMAS</div>
    <div id="loading">ƒêang t·∫£i qu√†...</div>
    <div id="canvas-container"></div>
    <div id="instructions">
        üñê ƒê∆∞a tay l√™n Camera <br> 
        üëå <b>Ch·ª•m ng√≥n tay</b> ƒë·ªÉ m·ªü h·ªôp qu√†!
    </div>
    <button id="settings-btn" title="C√†i ƒë·∫∑t thi·ªáp">‚öôÔ∏è</button>
    <a id="create-new-link" href="#" target="_blank">T·∫°o thi·ªáp m·ªõi</a>
    <div id="settings-modal">
        <div class="modal-content">
            <h2>üéÅ C√ÄI ƒê·∫∂T & CLOUDINARY</h2>
            <div class="form-group">
                <label>1. C·∫•u h√¨nh Cloudinary (Mi·ªÖn ph√≠, kh√¥ng c·∫ßn th·∫ª):</label>
                <input type="text" id="inp-cloud-name" placeholder="Cloud Name (VD: dyhex...)" style="margin-bottom:5px;">
                <input type="text" id="inp-upload-preset" placeholder="Upload Preset (VD: ml_default)">
                <div style="font-size: 0.75rem; color: #888; margin-top:3px;">
                    * V√†o Cloudinary > Settings > Upload > Add preset > Ch·ªçn "Unsigned" mode.
                </div>
            </div>
            <div class="form-group">
                <label>2. T·∫£i ·∫£nh l√™n (S·∫Ω l∆∞u v√†o Cloudinary):</label>
                <div class="file-upload-wrapper" onclick="document.getElementById('inp-files').click()">
                    <span style="color:#4ade80; font-weight:bold;">üìÅ Ch·ªçn ·∫£nh t·ª´ m√°y</span>
                    <div id="file-count">Ch∆∞a ch·ªçn ·∫£nh n√†o</div>
                </div>
                <input type="file" id="inp-files" multiple accept="image/*" style="display:none">
            </div>
            <div class="form-group">
                <label>3. Link Nh·∫°c YouTube & L·ªùi Ch√∫c:</label>
                <input type="text" id="inp-youtube" placeholder="ID Youtube (VD: R3Xy54qM93w)" style="margin-bottom:5px;">
                <input type="text" id="inp-message" placeholder="L·ªùi ch√∫c (VD: MERRY CHRISTMAS)" maxlength="20">
            </div>
            <div class="btn-group">
                <button class="action-btn btn-close" id="btn-cancel">ƒê√≥ng</button>
                <button class="action-btn btn-save" id="btn-create">L∆∞u & Upload l√™n M√¢y</button>
            </div>
            <div id="share-link-container">
                <div style="color: #aaa; margin-bottom: 5px;">Link chia s·∫ª:</div>
                <div id="share-link"></div>
                <button class="action-btn" style="background: #4ade80; color: #000; margin-top:10px; font-size:14px;" id="btn-copy">Sao ch√©p Link</button>
            </div>
        </div>
    </div>
    <video class="input_video" playsinline autoplay muted></video>
    <div id="youtube-player"></div>

    <script type="importmap">
        {
            "imports": {
                "three": "https://unpkg.com/three@0.160.0/build/three.module.js",
                "three/addons/": "https://unpkg.com/three@0.160.0/examples/jsm/"
            }
        }
    </script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/gsap/3.12.2/gsap.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/control_utils/control_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/drawing_utils/drawing_utils.js" crossorigin="anonymous"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js" crossorigin="anonymous"></script>

    <script type="module">
        import * as THREE from 'three';
        import { OrbitControls } from 'three/addons/controls/OrbitControls.js';
        import { FontLoader } from 'three/addons/loaders/FontLoader.js';
        import { TextGeometry } from 'three/addons/geometries/TextGeometry.js';
        import { EffectComposer } from 'three/addons/postprocessing/EffectComposer.js';
        import { RenderPass } from 'three/addons/postprocessing/RenderPass.js';
        import { UnrealBloomPass } from 'three/addons/postprocessing/UnrealBloomPass.js';
        import { RoomEnvironment } from 'three/addons/environments/RoomEnvironment.js';
        import { MeshSurfaceSampler } from 'three/addons/math/MeshSurfaceSampler.js';
        
        // --- C·∫§U H√åNH ---
        const DEFAULT_CONFIG = {
            images: ['https://images.unsplash.com/photo-1543589077-47d81606c1bf?q=80&w=1000'],
            youtubeId: 'R3Xy54qM93w', 
            message: 'MERRY\nCHRISTMAS', 
            cloudName: '',
            uploadPreset: ''
        };

        let USER_CONFIG = { ...DEFAULT_CONFIG };
        let currentImageIndex = 0;
        let isCreatorMode = true;

        // --- X·ª¨ L√ù URL ---
        function loadConfigFromURL() {
            const params = new URLSearchParams(window.location.search);
            if (params.has('data')) {
                isCreatorMode = false;
                try {
                    const decoded = JSON.parse(atob(params.get('data')));
                    if (decoded.images) USER_CONFIG.images = decoded.images;
                    if (decoded.youtubeId) USER_CONFIG.youtubeId = decoded.youtubeId;
                    if (decoded.message) USER_CONFIG.message = decoded.message;
                    document.getElementById('title').innerText = USER_CONFIG.message.replace('\n', ' ');
                } catch (e) { console.error("L·ªói link", e); }
                document.getElementById('settings-btn').style.display = 'none';
                const createLink = document.getElementById('create-new-link');
                createLink.href = window.location.pathname; 
                createLink.style.display = 'block';
            } else {
                isCreatorMode = true;
                document.getElementById('settings-btn').style.display = 'flex';
                const savedCloud = localStorage.getItem('cloud_config');
                if(savedCloud) {
                    const parsed = JSON.parse(savedCloud);
                    USER_CONFIG.cloudName = parsed.cloudName;
                    USER_CONFIG.uploadPreset = parsed.uploadPreset;
                }
            }
        }
        loadConfigFromURL();

        // --- GIAO DI·ªÜN ---
        const modal = document.getElementById('settings-modal');
        const btnSettings = document.getElementById('settings-btn');
        const btnCreate = document.getElementById('btn-create');
        const btnCopy = document.getElementById('btn-copy');
        const inpFiles = document.getElementById('inp-files');
        const fileCount = document.getElementById('file-count');

        inpFiles.addEventListener('change', () => {
            const count = inpFiles.files.length;
            fileCount.innerText = count > 0 ? `ƒê√£ ch·ªçn ${count} ·∫£nh` : "Ch∆∞a ch·ªçn ·∫£nh n√†o";
            fileCount.style.color = count > 0 ? "#4ade80" : "#aaa";
        });

        const uploadToCloudinary = async (file, cloudName, preset) => {
            const formData = new FormData();
            formData.append('file', file);
            formData.append('upload_preset', preset);
            const response = await fetch(`https://api.cloudinary.com/v1_1/${cloudName}/image/upload`, {
                method: 'POST', body: formData
            });
            if (!response.ok) throw new Error('Upload th·∫•t b·∫°i');
            const data = await response.json();
            return data.secure_url;
        };

        if (isCreatorMode) {
            btnSettings.onclick = () => {
                document.getElementById('inp-youtube').value = USER_CONFIG.youtubeId;
                document.getElementById('inp-message').value = USER_CONFIG.message.replace('\n', ' ');
                document.getElementById('inp-cloud-name').value = USER_CONFIG.cloudName || '';
                document.getElementById('inp-upload-preset').value = USER_CONFIG.uploadPreset || '';
                modal.style.display = 'flex';
            };
            document.getElementById('btn-cancel').onclick = () => { modal.style.display = 'none'; };
            btnCreate.onclick = async () => {
                const ytInput = document.getElementById('inp-youtube').value.trim();
                const msgInput = document.getElementById('inp-message').value.toUpperCase().trim();
                const cloudName = document.getElementById('inp-cloud-name').value.trim();
                const uploadPreset = document.getElementById('inp-upload-preset').value.trim();
                const files = inpFiles.files;
                if (files.length > 0 && (!cloudName || !uploadPreset)) {
                    alert("B·∫°n ch∆∞a nh·∫≠p Cloud Name ho·∫∑c Upload Preset c·ªßa Cloudinary!"); return;
                }
                localStorage.setItem('cloud_config', JSON.stringify({ cloudName, uploadPreset }));
                let imageUrls = [];
                if (files.length > 0) {
                    btnCreate.innerText = "ƒêang Upload l√™n Cloudinary..."; btnCreate.disabled = true;
                    try {
                        const uploadPromises = Array.from(files).map(file => uploadToCloudinary(file, cloudName, uploadPreset));
                        imageUrls = await Promise.all(uploadPromises);
                    } catch (error) {
                        alert("L·ªói Upload: Ki·ªÉm tra Cloud Name/Preset!"); btnCreate.innerText = "L∆∞u & Upload l√™n M√¢y"; btnCreate.disabled = false; return;
                    }
                } else { imageUrls = DEFAULT_CONFIG.images; }
                let ytId = ytInput || DEFAULT_CONFIG.youtubeId;
                const ytMatch = ytId.match(/(?:youtube\.com\/(?:[^\/]+\/.+\/|(?:v|e(?:mbed)?)\/|.*[?&]v=)|youtu\.be\/)([^"&?\/\s]{11})/);
                if (ytMatch) ytId = ytMatch[1];
                USER_CONFIG.youtubeId = ytId; USER_CONFIG.message = msgInput || DEFAULT_CONFIG.message; USER_CONFIG.images = imageUrls;
                
                document.getElementById('title').innerText = USER_CONFIG.message.replace('\n', ' ');
                if(player && player.loadVideoById) player.loadVideoById(ytId);
                currentImageIndex = 0; loadNextImage(); generateTextParticles(USER_CONFIG.message);
                
                const shareConfig = { youtubeId: ytId, message: USER_CONFIG.message, images: imageUrls };
                const newURL = `${window.location.origin}${window.location.pathname}?data=${btoa(JSON.stringify(shareConfig))}`;
                document.getElementById('share-link-container').style.display = 'block';
                document.getElementById('share-link').innerText = newURL;
                btnCreate.innerText = "Th√†nh c√¥ng!"; btnCreate.disabled = false;
            };
            btnCopy.onclick = () => {
                navigator.clipboard.writeText(document.getElementById('share-link').innerText).then(() => alert("ƒê√£ copy link!"));
            };
        }

        // --- THREE.JS LOGIC (CLEAN & SHARP) ---
        const PARTICLE_COUNT = 20000; // TƒÉng l√™n 20,000 ƒë·ªÉ h·∫°t si√™u m·ªãn
        const TREE_HEIGHT = 22;
        const TREE_RADIUS = 10;
        const BASE_COLORS = [ new THREE.Color(0xD4AF37), new THREE.Color(0x8B0000), new THREE.Color(0x006400), new THREE.Color(0xC0C0C0) ];
        const GLOW_COLOR = new THREE.Color(0xFFFFE0);
        const STATES = { TREE: 0, BOX: 1, PHOTO: 2, TEXT: 3 };
        let currentState = STATES.TREE;
        let isAnimating = false;

        const container = document.getElementById('canvas-container');
        const scene = new THREE.Scene();
        scene.fog = new THREE.FogExp2(0x000000, 0.02);
        const camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
        camera.position.set(0, 5, 45);
        const renderer = new THREE.WebGLRenderer({ antialias: false });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.setPixelRatio(Math.min(window.devicePixelRatio, 2));
        renderer.toneMapping = THREE.ReinhardToneMapping;
        container.appendChild(renderer.domElement);

        const pmremGenerator = new THREE.PMREMGenerator(renderer);
        scene.environment = pmremGenerator.fromScene(new RoomEnvironment(), 0.04).texture;
        const controls = new OrbitControls(camera, renderer.domElement);
        controls.enableDamping = true; controls.autoRotate = true; controls.autoRotateSpeed = 0.5;

        const renderScene = new RenderPass(scene, camera);
        // Gi·∫£m b√°n k√≠nh Bloom ƒë·ªÉ ch·ªØ ƒë·ª° b·ªã l√≥a v√†o nhau
        const bloomPass = new UnrealBloomPass(new THREE.Vector2(window.innerWidth, window.innerHeight), 1.0, 0.3, 0.85);
        const composer = new EffectComposer(renderer);
        composer.addPass(renderScene); composer.addPass(bloomPass);

        const ambientLight = new THREE.AmbientLight(0xffffff, 0.4); scene.add(ambientLight);
        const dirLight = new THREE.DirectionalLight(0xffeeb1, 2); dirLight.position.set(10, 20, 10); scene.add(dirLight);

        // Snow
        const snowGeo = new THREE.BufferGeometry();
        const snowCount = 800;
        const snowPos = new Float32Array(snowCount * 3);
        const snowVelocities = [];
        for(let i=0; i<snowCount; i++) {
            snowPos[i*3] = (Math.random() - 0.5) * 100; snowPos[i*3+1] = (Math.random() - 0.5) * 100; snowPos[i*3+2] = (Math.random() - 0.5) * 100;
            snowVelocities.push(0.02 + Math.random() * 0.05);
        }
        snowGeo.setAttribute('position', new THREE.BufferAttribute(snowPos, 3));
        const snowSystem = new THREE.Points(snowGeo, new THREE.PointsMaterial({ color: 0xffffff, size: 0.2, transparent: true, opacity: 0.6, blending: THREE.AdditiveBlending }));
        scene.add(snowSystem);

        // 2. H·∫†T SI√äU NH·ªé V√Ä S·∫ÆC N√âT
        const sphereGeo = new THREE.SphereGeometry(0.09, 8, 8); // H·∫°t nh·ªè
        const cubeGeo = new THREE.BoxGeometry(0.14, 0.14, 0.14); // H·∫°t nh·ªè
        const material = new THREE.MeshStandardMaterial({ metalness: 0.8, roughness: 0.15, envMapIntensity: 1.0 });
        const spheresMesh = new THREE.InstancedMesh(sphereGeo, material, PARTICLE_COUNT / 2);
        const cubesMesh = new THREE.InstancedMesh(cubeGeo, material, PARTICLE_COUNT / 2);
        scene.add(spheresMesh); scene.add(cubesMesh);

        // Photo Mesh
        let photoMesh;
        const texLoader = new THREE.TextureLoader();
        texLoader.crossOrigin = "anonymous"; 
        function loadNextImage() {
            if (!USER_CONFIG.images || USER_CONFIG.images.length === 0) return;
            const url = USER_CONFIG.images[currentImageIndex];
            texLoader.load(url, (texture) => {
                if(photoMesh) scene.remove(photoMesh);
                const aspect = texture.image.width / texture.image.height;
                let w, h;
                if (aspect > 1) { w = 14; h = 14 / aspect; } else { h = 12; w = 12 * aspect; }
                const photoGeo = new THREE.PlaneGeometry(w, h);
                const photoMat = new THREE.MeshBasicMaterial({ map: texture, side: THREE.DoubleSide, transparent: true, opacity: 0 });
                photoMesh = new THREE.Mesh(photoGeo, photoMat);
                photoMesh.scale.set(0,0,0);
                scene.add(photoMesh);
            }, undefined, (err) => { console.error("L·ªói ·∫£nh:", err); });
            currentImageIndex = (currentImageIndex + 1) % USER_CONFIG.images.length;
        }
        loadNextImage();

        const dummy = new THREE.Object3D();
        const tempColor = new THREE.Color();
        const treePositions = []; const boxPositions = []; const explodedPositions = []; let textPositions = []; 
        const currentPositions = []; const twinkleData = []; 

        for (let i = 0; i < PARTICLE_COUNT; i++) {
            const ratio = i / PARTICLE_COUNT;
            const h = TREE_HEIGHT * (1 - ratio) - (TREE_HEIGHT/2);
            const r = TREE_RADIUS * Math.pow(ratio, 0.9); 
            const a = i * 2.4 + Math.random();
            const pos = { x: Math.cos(a) * r, y: h, z: Math.sin(a) * r };
            treePositions.push(pos); currentPositions.push({ ...pos });
            let baseC;
            if (i % 3 === 0) baseC = BASE_COLORS[0];
            else if (i % 3 === 1) baseC = BASE_COLORS[1];
            else baseC = Math.random() > 0.5 ? BASE_COLORS[2] : BASE_COLORS[3];
            twinkleData.push({ phase: Math.random() * Math.PI * 2, speed: 1 + Math.random() * 3, baseColor: baseC, isSphere: i % 2 === 0, indexInMesh: Math.floor(i / 2) });
        }

        const boxSize = 6;
        for (let i = 0; i < PARTICLE_COUNT; i++) {
            const face = Math.floor(Math.random() * 6);
            let x, y, z;
            const u = (Math.random() - 0.5) * boxSize; const v = (Math.random() - 0.5) * boxSize; const off = boxSize / 2;
            switch(face) {
                case 0: x = off; y = u; z = v; break; case 1: x = -off; y = u; z = v; break;
                case 2: x = u; y = off; z = v; break; case 3: x = u; y = -off; z = v; break;
                case 4: x = u; y = v; z = off; break; case 5: x = u; y = v; z = -off; break;
            }
            boxPositions.push({ x, y, z });
        }

        for (let i = 0; i < PARTICLE_COUNT; i++) {
            const r = 25 + Math.random() * 20;
            const theta = Math.random() * Math.PI * 2;
            const phi = Math.acos(2 * Math.random() - 1);
            explodedPositions.push({ x: r * Math.sin(phi) * Math.cos(theta), y: r * Math.sin(phi) * Math.sin(theta), z: r * Math.cos(phi) });
        }

        const fontLoader = new FontLoader();
        let loadedFont = null;
        
        // 3. LOGIC T·∫†O CH·ªÆ T√ÅCH B·∫†CH
        function generateTextParticles(message) {
            if (!loadedFont) return;
            textPositions = [];
            const formattedMsg = message.replace(/\\n/g, '\n');
            const textGeo = new TextGeometry(formattedMsg, { 
                font: loadedFont, 
                size: 3.0, // Gi·∫£m size ch·ªØ xu·ªëng m·ªôt ch√∫t
                height: 0.5, 
                curveSegments: 12,
                // QUAN TR·ªåNG: Gi·∫£m bevelSize ƒë·ªÉ c√°c ch·ªØ kh√¥ng d√≠nh v√†o nhau
                bevelEnabled: true, bevelThickness: 0.4, bevelSize: 0.01, bevelSegments: 5 
            });
            textGeo.center();

            const tempMesh = new THREE.Mesh(textGeo, new THREE.MeshBasicMaterial());
            const sampler = new MeshSurfaceSampler(tempMesh).build();
            const tempPosition = new THREE.Vector3();

            for (let i = 0; i < PARTICLE_COUNT; i++) {
                sampler.sample(tempPosition);
                textPositions.push({ 
                    x: tempPosition.x, 
                    y: tempPosition.y, 
                    z: tempPosition.z 
                });
            }
        }

        fontLoader.load('https://unpkg.com/three@0.160.0/examples/fonts/helvetiker_bold.typeface.json', (font) => {
            loadedFont = font;
            generateTextParticles(USER_CONFIG.message);
            updateMesh(0);
            document.getElementById('loading').innerText = "ƒêang kh·ªüi ƒë·ªông Camera...";
            initCamera();
        });

        const topperGeo = new THREE.OctahedronGeometry(1.5, 0);
        const topperMat = new THREE.MeshStandardMaterial({ color: 0xFFD700, emissive: 0xFFD700, emissiveIntensity: 0.8 });
        const topper = new THREE.Mesh(topperGeo, topperMat);
        topper.position.set(0, TREE_HEIGHT/2 + 1.5, 0);
        scene.add(topper);

        function updateMesh(time) {
            for (let i = 0; i < PARTICLE_COUNT; i++) {
                const { x, y, z } = currentPositions[i];
                dummy.position.set(x, y, z);
                dummy.rotation.set(time * 0.5 + i, time * 0.3 + i, 0);
                dummy.updateMatrix();
                const data = twinkleData[i];
                const blinkValue = Math.sin(time * data.speed + data.phase);
                if (blinkValue > 0.85) {
                    const intensity = (blinkValue - 0.85) * 6.6;
                    tempColor.lerpColors(data.baseColor, GLOW_COLOR, intensity);
                } else { tempColor.copy(data.baseColor); }
                if (data.isSphere) {
                    spheresMesh.setMatrixAt(data.indexInMesh, dummy.matrix);
                    spheresMesh.setColorAt(data.indexInMesh, tempColor);
                } else {
                    cubesMesh.setMatrixAt(data.indexInMesh, dummy.matrix);
                    cubesMesh.setColorAt(data.indexInMesh, tempColor);
                }
            }
            spheresMesh.instanceMatrix.needsUpdate = true;
            spheresMesh.instanceColor.needsUpdate = true;
            cubesMesh.instanceMatrix.needsUpdate = true;
            cubesMesh.instanceColor.needsUpdate = true;
        }

        function triggerNextState() {
            if (isAnimating) return;
            isAnimating = true;
            tryPlayMusic();
            let targetData, nextState;
            if (currentState === STATES.TREE) {
                targetData = boxPositions; nextState = STATES.BOX;
                gsap.to(topper.scale, { x: 0, y: 0, z: 0, duration: 0.5 });
                controls.autoRotateSpeed = 2.0;
            } else if (currentState === STATES.BOX) {
                targetData = explodedPositions; nextState = STATES.PHOTO;
                if(photoMesh) {
                    gsap.to(photoMesh.scale, { x: 1, y: 1, z: 1, duration: 1.5, ease: "elastic.out(1, 0.5)" });
                    gsap.to(photoMesh.material, { opacity: 1, duration: 0.5 });
                    gsap.to(photoMesh.rotation, { y: Math.PI * 2, duration: 2, ease: "power2.out" });
                }
                controls.autoRotateSpeed = 0.5;
            } else if (currentState === STATES.PHOTO) {
                targetData = textPositions; nextState = STATES.TEXT;
                if(photoMesh) {
                    gsap.to(photoMesh.scale, { x: 0, y: 0, z: 0, duration: 0.5 });
                    gsap.to(photoMesh.material, { opacity: 0, duration: 0.5 });
                }
                gsap.to(camera.position, { x: 0, y: 0, z: 35, duration: 1.5 });
            } else {
                targetData = treePositions; nextState = STATES.TREE;
                loadNextImage();
                generateTextParticles(USER_CONFIG.message);
                gsap.to(topper.scale, { x: 1, y: 1, z: 1, duration: 1, delay: 1, ease: "elastic.out(1, 0.7)" });
                controls.autoRotate = true;
            }
            const animObj = { val: 0 };
            const startPositions = JSON.parse(JSON.stringify(currentPositions));
            gsap.to(animObj, {
                val: 1, duration: 1.5, ease: "power2.inOut",
                onUpdate: () => {
                    for (let i = 0; i < PARTICLE_COUNT; i++) {
                        currentPositions[i].x = THREE.MathUtils.lerp(startPositions[i].x, targetData[i].x, animObj.val);
                        currentPositions[i].y = THREE.MathUtils.lerp(startPositions[i].y, targetData[i].y, animObj.val);
                        currentPositions[i].z = THREE.MathUtils.lerp(startPositions[i].z, targetData[i].z, animObj.val);
                    }
                },
                onComplete: () => { currentState = nextState; isAnimating = false; }
            });
        }

        let player;
        window.onYouTubeIframeAPIReady = function() {
            player = new YT.Player('youtube-player', {
                height: '0', width: '0', videoId: USER_CONFIG.youtubeId,
                playerVars: { 'autoplay': 1, 'controls': 0, 'loop': 1, 'playlist': USER_CONFIG.youtubeId },
                events: { 'onReady': (e) => e.target.playVideo() }
            });
        };
        function tryPlayMusic() { if (player && player.playVideo) player.playVideo(); }
        var tag = document.createElement('script');
        tag.src = "https://www.youtube.com/iframe_api";
        var firstScriptTag = document.getElementsByTagName('script')[0];
        firstScriptTag.parentNode.insertBefore(tag, firstScriptTag);

        function animate() {
            requestAnimationFrame(animate);
            controls.update();
            const time = Date.now() * 0.001;
            const positions = snowSystem.geometry.attributes.position.array;
            for(let i=0; i<snowCount; i++) {
                positions[i*3+1] -= snowVelocities[i];
                if (positions[i*3+1] < -50) positions[i*3+1] = 50;
            }
            snowSystem.geometry.attributes.position.needsUpdate = true;
            topper.rotation.y += 0.01;
            updateMesh(time);
            composer.render();
        }
        
        let lastGestureTime = 0; 
        const GESTURE_COOLDOWN = 2000;
        function onResults(results) {
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                const landmarks = results.multiHandLandmarks[0];
                const thumbTip = landmarks[4]; const indexTip = landmarks[8];
                const distance = Math.sqrt(Math.pow(thumbTip.x - indexTip.x, 2) + Math.pow(thumbTip.y - indexTip.y, 2));
                if (distance < 0.05) {
                    const now = Date.now();
                    if (now - lastGestureTime > GESTURE_COOLDOWN) {
                        triggerNextState(); 
                        lastGestureTime = now;
                        gsap.fromTo(document.getElementById('title'), {textShadow: "0 0 50px white"}, {textShadow: "0 0 10px #FFD700", duration: 1});
                    }
                }
            }
        }
        function initCamera() {
            const videoElement = document.querySelector('.input_video');
            const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
            hands.setOptions({ maxNumHands: 1, modelComplexity: 0, minDetectionConfidence: 0.5, minTrackingConfidence: 0.5 });
            hands.onResults(onResults);
            const cameraUtils = new Camera(videoElement, { onFrame: async () => { await hands.send({image: videoElement}); }, width: 320, height: 240 });
            cameraUtils.start().then(() => {
                document.getElementById('loading').style.opacity = 0;
                animate();
            }).catch(err => {
                document.getElementById('loading').innerText = "L·ªói Camera. V·∫´n ch·∫°y animation...";
                setTimeout(() => document.getElementById('loading').style.opacity = 0, 2000);
                animate();
            });
        }
        window.addEventListener('mousedown', (e) => {
            if (!e.target.closest('#settings-modal') && !e.target.closest('#settings-btn')) triggerNextState();
        });
        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
            composer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>